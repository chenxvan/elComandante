/**
 * \file action_context_t.h
 * \author Dennis Terhorst
 * \date Thu Jul  2 12:18:52 CEST 2009
 */
#ifndef ACTION_CONTEXT_T_H
#define ACTION_CONTEXT_T_H
#include "sensations.h"
#include "packet_description_t.h"
#include "action_t.h"

#include <list>
#include <iostream>
#include <string>
using namespace std;

class action_context_t {
	typedef list<packet_description_t*> packet_descriptions;
	
	//list<on_clause_t*> pktdescriptions;
	//list<action_t*>  actions;
	packet_descriptions pd;
	string name;
	action_context_t* parent;

public:	// Parser stuff (see Tutorial of Edsko de Vries)
	void*		scanner;	// scanner context for the reentrant (pure) parser
	istream*	is;		// parser input stream
	int		esc_depth;	// escaping depth

public:
	action_context_t(string _name, action_context_t* _parent=NULL, istream* _is = &cin) {
		parent = _parent;
		name = _name;
		is = _is;
		init_scanner();
	}
	virtual ~action_context_t() {
		destroy_scanner();
	}
//	void add(action A) {}
//	void add(on_clause C) {}
	void add(packet_description_t* PD) {
		pd.push_back(PD);
	}
	bool find_sens(string search, sens_value_t*& sens) {
		for (packet_descriptions::iterator iter=pd.begin(); iter != pd.end(); ++iter) {
			if ( (*iter)->get_sens(search, sens) ) {
				return true;
			} else {
				cout << "could not find " << search << " in packet_description" << endl;
			}
		}
		return false;
	}

	string Name() {
		return name;
	}
	string FullName() {
		if ( parent == NULL ) return this->Name();
		return parent->FullName()+"/"+ this->Name();
	}
	void list_packet_definitions() {
		cout << "LIST OF PACKET DEFINITIONS:" << endl;
		for (packet_descriptions::iterator iter=pd.begin(); iter!=pd.end(); ++iter) {
			cout << "\t" << *iter << endl;
		}
		cout << pd.size() << " total" << endl;
	}
private:
	void init_scanner();   	// Defined in subscript.l
	void destroy_scanner();	// Defined in subscript.l
};

// scanner generated by bison (subscript.y)
int subscript_parse(action_context_t*);

#endif //ndef ACTION_CONTEXT_T_H
